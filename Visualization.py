# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ReEzV0dvnPFbjVLd_zFTjCvnNBZS4a9E
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import json
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import GaussianNB
from IPython.display import display, Markdown

# --- 1. Synthetic Data Generation Function ---

def generate_synthetic_data(n_samples=2000, seed=42):
    """Generates synthetic force-based sensor data for AC Louver Knobs."""
    np.random.seed(seed)

    # Nominal values and tolerances - ADJUSTED FOR 1-8N RANGE
    NOMINAL_UD_FORCE = 4.0   # Nominal Up-Down Max Force (N)
    TOLERANCE_UD = 1.0       # Up-Down Tolerance (+- 1N) -> Range 3-5N
    NOMINAL_SS_FORCE = 5.0   # Nominal Side-Side Max Force (N)
    TOLERANCE_SS = 1.5       # Side-Side Tolerance (+- 1.5N) -> Range 3.5-6.5N

    # Generate data for Good and Bad parts (same logic as before, adjusted for new range)
    n_good = int(n_samples * 0.8)
    ud_force_good = np.random.normal(NOMINAL_UD_FORCE, 0.3, n_good) # Smaller std dev for tighter good range
    ss_force_good = np.random.normal(NOMINAL_SS_FORCE, 0.5, n_good)
    ud_smooth_good = np.random.normal(0.5, 0.1, n_good)
    ss_smooth_good = np.random.normal(0.8, 0.15, n_good)

    n_bad = n_samples - n_good
    # Adjusted bad force ranges to be outside new nominals/tolerances but within reasonable overall 1-8N context
    bad_ud_force_low = np.random.uniform(NOMINAL_UD_FORCE - TOLERANCE_UD - 2, NOMINAL_UD_FORCE - TOLERANCE_UD - 0.5, int(n_bad * 0.3)) # e.g., 1 to 2.5N
    bad_ud_force_high = np.random.uniform(NOMINAL_UD_FORCE + TOLERANCE_UD + 0.5, NOMINAL_UD_FORCE + TOLERANCE_UD + 2, int(n_bad * 0.3)) # e.g., 5.5 to 7N
    ud_force_bad = np.concatenate([bad_ud_force_low, bad_ud_force_high])

    bad_ss_force_low = np.random.uniform(NOMINAL_SS_FORCE - TOLERANCE_SS - 2.5, NOMINAL_SS_FORCE - TOLERANCE_SS - 0.5, int(n_bad * 0.2)) # e.g., 1 to 3N
    bad_ss_force_high = np.random.uniform(NOMINAL_SS_FORCE + TOLERANCE_SS + 0.5, NOMINAL_SS_FORCE + TOLERANCE_SS + 2.5, int(n_bad * 0.2)) # e.g., 7 to 9N (can slightly exceed 8)
    ss_force_bad = np.concatenate([bad_ss_force_low, bad_ss_force_high])

    n_bad_smooth = n_bad - len(ud_force_bad) - len(ss_force_bad)
    ud_smooth_bad = np.random.uniform(2.0, 4.0, n_bad_smooth) # Assuming these thresholds remain relevant for smoothness
    ss_smooth_bad = np.random.uniform(2.5, 5.0, n_bad_smooth)

    df = pd.DataFrame({
        'UD_Max_Force': np.concatenate([ud_force_good, np.random.choice(ud_force_bad, len(ud_force_bad)), np.random.normal(NOMINAL_UD_FORCE, 0.3, len(ss_force_bad)), np.random.normal(NOMINAL_UD_FORCE, 0.2, n_bad_smooth)]),
        'SS_Max_Force': np.concatenate([ss_force_good, np.random.normal(NOMINAL_SS_FORCE, 0.5, len(ud_force_bad)), np.random.choice(ss_force_bad, len(ss_force_bad)), np.random.normal(NOMINAL_SS_FORCE, 0.2, n_bad_smooth)]),
        'UD_Force_StdDev': np.concatenate([ud_smooth_good, np.random.normal(0.6, 0.1, len(ud_force_bad)), np.random.normal(0.6, 0.1, len(ss_force_bad)), ud_smooth_bad]),
        'SS_Force_StdDev': np.concatenate([ss_smooth_good, np.random.normal(0.8, 0.2, len(ud_force_bad)), np.random.normal(0.8, 0.2, len(ss_force_bad)), ss_smooth_bad]),
    })

    # Ensure all forces are positive and within a reasonable max for this context (e.g., max 9N for bad cases)
    df['UD_Max_Force'] = np.clip(df['UD_Max_Force'], 0.5, 9.0)
    df['SS_Max_Force'] = np.clip(df['SS_Max_Force'], 0.5, 9.0)


    is_ud_bad = (df['UD_Max_Force'] < NOMINAL_UD_FORCE - TOLERANCE_UD) | (df['UD_Max_Force'] > NOMINAL_UD_FORCE + TOLERANCE_UD) | (df['UD_Force_StdDev'] > 1.5)
    is_ss_bad = (df['SS_Max_Force'] < NOMINAL_SS_FORCE - TOLERANCE_SS) | (df['SS_Max_Force'] > NOMINAL_SS_FORCE + TOLERANCE_SS) | (df['SS_Force_StdDev'] > 2.0)

    df['Quality_Label'] = np.where(is_ud_bad | is_ss_bad, 1, 0)

    return df.sample(n=n_samples, random_state=seed).reset_index(drop=True)

# --- 2. Model Training and Preprocessing ---

def train_models(df):
    """Preprocesses data, trains KNN and Naive Bayes models."""
    X = df[['UD_Max_Force', 'SS_Max_Force', 'UD_Force_StdDev', 'SS_Force_StdDev']]
    y = df['Quality_Label']

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)

    scaler = StandardScaler()
    X_train_scaled = scaler.fit_transform(X_train)

    # 1. KNN for Classification
    knn_model = KNeighborsClassifier(n_neighbors=5)
    knn_model.fit(X_train_scaled, y_train)

    # 2. Gaussian Naive Bayes for Prediction/Prognosis
    nb_model = GaussianNB()
    nb_model.fit(X_train_scaled, y_train)

    return knn_model, nb_model, scaler, X_test, y_test

# --- 3. Seaborn Visualization Function ---

def make_seaborn_plot(df_train, df_new_sample):
    """Creates a Seaborn line plot of Max Forces colored by Quality Label."""
    plt.style.use('ggplot')
    fig, ax = plt.subplots(figsize=(8, 6))

    # Plotting training data as a line graph with markers for individual points
    # Using estimator=None, markers=True, dashes=False to make lineplot behave like scatter
    sns.lineplot(
        data=df_train,
        x='UD_Max_Force',
        y='SS_Max_Force',
        hue='Quality_Label',
        palette={0: '#33a02c', 1: '#e31a1c'},
        style='Quality_Label',
        markers=True, # Display markers for each point
        dashes=False, # Do not draw lines connecting points
        ax=ax,
        legend=False,
        estimator=None # Plot individual observations rather than estimates
    )

    # Plotting the new input sample
    ax.scatter(
        df_new_sample['UD_Max_Force'],
        df_new_sample['SS_Max_Force'],
        color='gold',
        marker='*',
        s=500,
        edgecolor='black',
        linewidth=1.5,
        label='New Test Sample (Input)'
    )

    # Draw tolerance boxes for visual reference
    # Adjusted tolerance bounds for the new force range
    ud_min, ud_max = 4.0 - 1.0, 4.0 + 1.0 # 3.0 to 5.0
    ss_min, ss_max = 5.0 - 1.5, 5.0 + 1.5 # 3.5 to 6.5
    ax.hlines([ss_min, ss_max], xmin=ud_min, xmax=ud_max, color='blue', linestyle='--', alpha=0.5, label='Tolerance Bounds')
    ax.vlines([ud_min, ud_max], ymin=ss_min, ymax=ss_max, color='blue', linestyle='--', alpha=0.5)

    ax.set_title('KNN Classification Space: Max Force Distribution (Line Graph)')
    ax.set_xlabel('Up-Down Max Force (N)')
    ax.set_ylabel('Side-Side Max Force (N)')
    ax.legend(title='Key', loc='upper right')
    plt.show(fig) # Use plt.show() in Jupyter

# --- 4. Main Execution Block for Jupyter ---

def run_inspection_system():
    # 1. Setup Data and Models
    data_df = generate_synthetic_data()
    knn_model, nb_model, scaler, X_test, y_test = train_models(data_df)

    # Report model performance
    X_test_scaled = scaler.transform(X_test)
    knn_accuracy = knn_model.score(X_test_scaled, y_test)
    nb_accuracy = nb_model.score(X_test_scaled, y_test)

    display(Markdown("## ⚙️ Automated Louver Knob Quality Inspection"))
    display(Markdown(f"**Model Performance on Test Data:** KNN Accuracy: **{knn_accuracy*100:.2f}%** | Naive Bayes Accuracy: **{nb_accuracy*100:.2f}%**"))
    display(Markdown("---"))

    # 2. User Input (Simulated)
    display(Markdown("## 1. Sensor Reading Input (Simulated)"))
    display(Markdown("### **Adjust the following values to simulate a new part's test results:**"))

    # --- INPUT VALUES (Change these to test different scenarios) ---
    ud_max_force = 4.5    # Simulate a slightly high Up-Down Force within new range
    ud_std_dev = 0.5       # Simulate a smooth Up-Down movement
    ss_max_force = 3.0    # Simulate a low Side-Side Force within new range (bad part)
    ss_std_dev = 1.0       # Simulate a moderately smooth Side-Side movement
    # -------------------------------------------------------------

    print(f"UD Max Force: {ud_max_force} N | UD Smoothness (StdDev): {ud_std_dev}")
    print(f"SS Max Force: {ss_max_force} N | SS Smoothness (StdDev): {ss_std_dev}")

    new_data = pd.DataFrame({
        'UD_Max_Force': [ud_max_force],
        'SS_Max_Force': [ss_max_force],
        'UD_Force_StdDev': [ud_std_dev],
        'SS_Force_StdDev': [ss_std_dev]
    })

    new_data_scaled = scaler.transform(new_data)

    display(Markdown("---"))

    # 3. Model Inference & Output
    display(Markdown("## 2. ML Model Results"))

    # KNN Classification
    knn_prediction = knn_model.predict(new_data_scaled)[0]
    result_map = {0: "**✅ GOOD PART** (Within Tolerance)", 1: "**❌ BAD PART** (Out of Tolerance/Defective)"}

    display(Markdown(f"### **K-Nearest Neighbors (KNN) Classification:**\nPart Status: {result_map[knn_prediction]}"))

    # Naive Bayes Prognosis
    nb_proba = nb_model.predict_proba(new_data_scaled)[0]
    prob_good = nb_proba[0]
    prob_bad = nb_proba[1]

    display(Markdown(f"### **Naive Bayes Prediction (Prognosis):**"))
    print(f"Probability of being GOOD: {prob_good*100:.1f}%")
    print(f"Probability of being BAD: {prob_bad*100:.1f}%")

    # Prognosis/Root Cause - Adjusted thresholds
    prognosis = "Overall performance is nominal."
    if ud_max_force < (4.0 - 1.0) or ud_max_force > (4.0 + 1.0): # UD tolerance 3-5N
        prognosis = "High risk due to **Up-Down Max Force** being out of the \u00b11N tolerance."
    elif ss_max_force < (5.0 - 1.5) or ss_max_force > (5.0 + 1.5): # SS tolerance 3.5-6.5N
        prognosis = "High risk due to **Side-Side Max Force** being out of the \u00b11.5N tolerance."
    elif ud_std_dev > 1.5 or ss_std_dev > 2.0:
        prognosis = "High risk due to **Force Smoothness (StdDev)**, indicating friction/sticking."

    display(Markdown(f"**Prognosis/Root Cause:** *{prognosis}*"))

    display(Markdown("---"))

    # 4. Save Sensor Data (JSON Output)
    display(Markdown("## 3. Save Sensor Data (JSON Output)"))

    # Convert the new input data (DataFrame) to a JSON string
    json_data = new_data.to_json(orient='records', indent=4)

    # In Jupyter, we print the JSON content instead of providing a download button
    display(Markdown("**JSON Data for Current Sensor Reading:**"))
    print(json_data)

    # To save this data to a file in Jupyter, you would use:
    # with open('sensor_reading_part.json', 'w') as f:
    # #     f.write(json_data)
    # print("\nData saved to 'sensor_reading_part.json'")

    display(Markdown("---"))

    # 5. Seaborn Visualization
    display(Markdown("## 4. Feature Visualization"))
    make_seaborn_plot(data_df, new_data)

# Execute the main function
run_inspection_system()